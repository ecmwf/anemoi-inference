# (C) Copyright 2024 Anemoi contributors.
#
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#
# In applying this licence, ECMWF does not waive the privileges and immunities
# granted to it by virtue of its status as an intergovernmental organisation
# nor does it submit to any jurisdiction.


import json
import sys
from argparse import ArgumentParser
from argparse import Namespace

from ..checkpoint import Checkpoint
from . import Command

CORE = ("models", "training", "graphs")


SKIP = {"anemoi-training"}

SKIP |= set(sys.stdlib_module_names) | set(sys.builtin_module_names)

PACKAGES = {
    "sklearn": "scikit-learn",
    "attr": "attrs",
    "google-protobuf": "protobuf",
}


class RequirementCmd(Command):
    """Extract requirements.txt from checkpoint."""

    def add_arguments(self, command_parser: ArgumentParser) -> None:
        """Add arguments to the command parser.

        Parameters
        ----------
        command_parser : ArgumentParser
            The argument parser to which the arguments will be added.
        """
        command_parser.description = self.__doc__
        command_parser.add_argument("--dump", action="store_true", help="Dump the relevant metadata.")
        command_parser.add_argument("path", help="Path to the checkpoint.")

    def run(self, args: Namespace) -> None:
        """Run the request command.

        Parameters
        ----------
        args : Namespace
            The arguments passed to the command.
        """

        c = Checkpoint(args.path)
        r = c.provenance_training()

        f = sys.stdout

        if args.dump:
            print(json.dumps(r, indent=2, sort_keys=True), file=f)
            return

        print("# This file is automatically generated from a checkpoint.", file=f)
        print("# Checkpoint:", args.path, file=f)
        print("# Python:", r.get("python"), file=f)
        print(file=f)

        distribution_names = r.get("distribution_names", {})
        distribution_names.update(PACKAGES)

        pypi_requirements = {}
        git_requirements = {}

        for k, v in r.get("module_versions", {}).items():
            if k.startswith("_"):
                continue
            if v[0].isdigit():
                v = [x for x in v.split(".") if x.isdigit()]
                v = ".".join(v)
                k = k.replace(".", "-")
                pypi_requirements[distribution_names.get(k, k)] = v

        for k, v in r.get("git_versions", {}).items():
            if not k.startswith("anemoi."):
                continue

            sha1 = v.get("git", {}).get("sha1")

            if not sha1:
                continue

            what = k.split(".")[-1]
            if what in CORE:
                url = f"git+https://github.com/ecmwf/anemoi-core@{sha1}#subdirectory={what}"
            else:
                url = f"git+https://github.com/ecmwf/anemoi-{what}@{sha1}"

            k = k.replace(".", "-")
            git_requirements[k] = url

        if git_requirements:
            print(file=f)
            print("# Git requirements:", file=f)
            print(file=f)

        for k, v in sorted(git_requirements.items()):
            if k in SKIP:
                continue

            version = pypi_requirements.pop(k, None)
            if version:
                print(f"# {k}=={version}", file=f)
            print(v, file=f)

        if pypi_requirements:
            print(file=f)
            print("# PyPI requirements:", file=f)
            print(file=f)

        for k, v in sorted(pypi_requirements.items()):
            if k in SKIP:
                continue

            print(f"{k}=={v}", file=f)


command = RequirementCmd
